<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of computeFormulasFillMetsCplex</title>
  <meta name="keywords" content="computeFormulasFillMetsCplex">
  <meta name="description" content="Compute the chemical formulas of the unknown metabolites">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<!-- menu.html MatlabCobraToolbox -->
<h1>computeFormulasFillMetsCplex
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>Compute the chemical formulas of the unknown metabolites</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [model,metCompute,S_fill,rxnBal,ele,metEle,N,LP] = computeFormulasFillMetsCplex(model,metKnown,rxns,metFill,findCM,nameCM,param) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Compute the chemical formulas of the unknown metabolites 
 using a set of metabolites with known formulae and a set of reactions.
 To include charge balance in the computation, simply in all formulas, add
 e.g. 'Charge2' for charge +2 or 'Charge-1' for charge -1. 'C' must be
 capitalized and 'harge' must be in lower case.
 The minimum conflict is found by allowing filling up by metFill (e.g. proton) in the reaction stoichiometry

 [model,metCompute,S_fill,rxnBal,ele,metEle,N] = computeFormulasFillMetsCplex(model,metKnown,rxns,metFill,findCM);
 Input:
   model:              COBRA model
   metKnown:           known metabolites (character array or IDs)
   rxns:               the set of reactions for inferring formulae (character array or IDs)
   metFill:            the chemical formulas for compounds for freely filling the
                       imbalance, e.g. {'HCharge1', 'H2O'}
   findCM = 'efmtool': find conserved moieties using EFMtool (most comprehensive, 
                       but computational cost may be high.)  
                       (default, if EFMtool not in path, switch to rational basis)
   findCM = true  :    find conserved moieties and add into formulas using the rational basis of model.S'
   findCM = N     :    directly supply the rational basis for N(S') or 
                       the set of extreme rays for {n | n * S = 0, n &gt;= 0}
   findCM = false :    not to find conserved moieties and return minimal formulas
 Output:
   model:          COBRA model with updated formulas
   metCompute:     M_unknown x 2 array of cell with [mets | computed formulas]
   S_fill:         mF x n matrix representing the adjustment of the S-matrix 
                   if you supply mF mets as 'metFill'
   rxnBal:         N by E matrix for the elemental balance of rxns, the ij-th
                   entry is the imbalance of the i-th rxn regarding the j-th element in 'ele'
   ele             elements corresponding to the row of rxnBal, as well as
                   to the coloumn of metEle
   metEle:         chemical formulas in a M by E matrix.
   N:              the extreme ray or rational null space matrix</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="../MatlabCobraToolbox/auxiliary_functions/checkEleBalance.html" class="code" title="function [EleBal, element, metEle] = checkEleBalance(model, element, metEle,selfCall)">checkEleBalance</a>	Check the elemental balance of the reactions in the COBRA mode 'model'.</li><li><a href="../MatlabCobraToolbox/auxiliary_functions/checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>	Check the feasibility of a solution given a COBRA model structure or a CPLEX dynamic object and a solution</li><li><a href="../MatlabCobraToolbox/auxiliary_functions/convertMatrixFormulas.html" class="code" title="function metForm = convertMatrixFormulas(element, metEle, dMax)">convertMatrixFormulas</a>	Convert the matrix form of the chemical formulae into string form</li><li><a href="../MatlabCobraToolbox/auxiliary_functions/setCplexParam.html" class="code" title="function LP = setCplexParam(LP, solverParam,verbFlag)">setCplexParam</a>	Set the parameters of the CPLEX object according to the structure solverParam</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function s = num2alpha(index,charSet)</a></li></ul>
<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [model,metCompute,S_fill,rxnBal,ele,metEle,N,LP] = computeFormulasFillMetsCplex(model,metKnown,rxns,metFill,findCM,nameCM,param)</a>
0002 <span class="comment">% Compute the chemical formulas of the unknown metabolites</span>
0003 <span class="comment">% using a set of metabolites with known formulae and a set of reactions.</span>
0004 <span class="comment">% To include charge balance in the computation, simply in all formulas, add</span>
0005 <span class="comment">% e.g. 'Charge2' for charge +2 or 'Charge-1' for charge -1. 'C' must be</span>
0006 <span class="comment">% capitalized and 'harge' must be in lower case.</span>
0007 <span class="comment">% The minimum conflict is found by allowing filling up by metFill (e.g. proton) in the reaction stoichiometry</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% [model,metCompute,S_fill,rxnBal,ele,metEle,N] = computeFormulasFillMetsCplex(model,metKnown,rxns,metFill,findCM);</span>
0010 <span class="comment">% Input:</span>
0011 <span class="comment">%   model:              COBRA model</span>
0012 <span class="comment">%   metKnown:           known metabolites (character array or IDs)</span>
0013 <span class="comment">%   rxns:               the set of reactions for inferring formulae (character array or IDs)</span>
0014 <span class="comment">%   metFill:            the chemical formulas for compounds for freely filling the</span>
0015 <span class="comment">%                       imbalance, e.g. {'HCharge1', 'H2O'}</span>
0016 <span class="comment">%   findCM = 'efmtool': find conserved moieties using EFMtool (most comprehensive,</span>
0017 <span class="comment">%                       but computational cost may be high.)</span>
0018 <span class="comment">%                       (default, if EFMtool not in path, switch to rational basis)</span>
0019 <span class="comment">%   findCM = true  :    find conserved moieties and add into formulas using the rational basis of model.S'</span>
0020 <span class="comment">%   findCM = N     :    directly supply the rational basis for N(S') or</span>
0021 <span class="comment">%                       the set of extreme rays for {n | n * S = 0, n &gt;= 0}</span>
0022 <span class="comment">%   findCM = false :    not to find conserved moieties and return minimal formulas</span>
0023 <span class="comment">% Output:</span>
0024 <span class="comment">%   model:          COBRA model with updated formulas</span>
0025 <span class="comment">%   metCompute:     M_unknown x 2 array of cell with [mets | computed formulas]</span>
0026 <span class="comment">%   S_fill:         mF x n matrix representing the adjustment of the S-matrix</span>
0027 <span class="comment">%                   if you supply mF mets as 'metFill'</span>
0028 <span class="comment">%   rxnBal:         N by E matrix for the elemental balance of rxns, the ij-th</span>
0029 <span class="comment">%                   entry is the imbalance of the i-th rxn regarding the j-th element in 'ele'</span>
0030 <span class="comment">%   ele             elements corresponding to the row of rxnBal, as well as</span>
0031 <span class="comment">%                   to the coloumn of metEle</span>
0032 <span class="comment">%   metEle:         chemical formulas in a M by E matrix.</span>
0033 <span class="comment">%   N:              the extreme ray or rational null space matrix</span>
0034 
0035 <span class="comment">%[model,metCompute,S_fill,rxnBal,ele,metEle,N] = computeFormulasFillMets(model,metKnown,rxns,metFill,findCM,nameCM);</span>
0036 <span class="comment">% nameCM = 0 the program assigns default names for conserved moieties</span>
0037 <span class="comment">%            (Conserve_a, Conserve_b, ...)</span>
0038 <span class="comment">% nameCM = 1 to name true conserved moieties interactively (exclude dead end mets).</span>
0039 <span class="comment">% nameCM = 2 to name all (including dead end)</span>
0040 <span class="comment">%</span>
0041 <span class="comment">% [model,metCompute,rxnBal,ele,metEle,N,LP] = computeFormulas(...)</span>
0042 <span class="comment">% Return also the CPLEX optimization object 'LP'</span>
0043 
0044 <span class="comment">%check mets with formulas that need to be transformed</span>
0045 <span class="comment">%form0 = model.metFormulas;</span>
0046 <span class="keyword">if</span> ~isfield(model,<span class="string">'metFormulas'</span>)
0047     error(<span class="string">'model does not have the field ''metFormulas.'''</span>)
0048 <span class="keyword">end</span>
0049 <span class="keyword">if</span> nargin &lt; 7 || isempty(param) 
0050     param = struct();
0051 <span class="keyword">end</span>
0052 <span class="keyword">if</span> nargin &lt; 6 || isempty(nameCM)
0053     nameCM = 0;
0054 <span class="keyword">end</span>
0055 <span class="keyword">if</span> nargin &lt; 5 || isempty(findCM)
0056     findCM = <span class="string">'efmtool'</span>;
0057 <span class="keyword">end</span>
0058 <span class="keyword">if</span> nargin &lt; 4 || isempty(metFill)
0059     <span class="comment">%defaulted proton for filling imbalance</span>
0060     metFill = {<span class="string">'HCharge1'</span>};
0061 <span class="keyword">elseif</span> ischar(metFill)
0062     metFill = {metFill};
0063 <span class="keyword">end</span>
0064 <span class="keyword">if</span> nargin &lt; 3 || isempty(rxns)
0065     rxns = find(sum(model.S~=0,1) &gt; 1 &amp; (model.lb ~= 0 | model.ub ~= 0)');
0066 <span class="keyword">end</span>
0067 <span class="keyword">if</span> ischar(rxns)
0068     rxns = {rxns};
0069 <span class="keyword">end</span>
0070 <span class="keyword">if</span> iscell(rxns)
0071     rxnC = findRxnIDs(model,rxns);
0072 <span class="keyword">else</span>
0073     rxnC = rxns;
0074 <span class="keyword">end</span>
0075 <span class="keyword">if</span> any(rxnC == 0)
0076     <span class="keyword">if</span> iscell(rxns)
0077         error(<span class="string">'%s in rxns is not in the model.'</span>, rxns{find(rxnC==0,1)});
0078     <span class="keyword">else</span>
0079         error(<span class="string">'rxns index must be positive integer.'</span>)
0080     <span class="keyword">end</span>
0081 <span class="keyword">end</span>
0082 <span class="keyword">if</span> nargin &lt; 2 || isempty(metKnown)
0083     metKnown = model.mets(~cellfun(@isempty,model.metFormulas));
0084 <span class="keyword">end</span>
0085 <span class="keyword">if</span> ischar(metKnown)
0086     metKnown = {metKnown};
0087 <span class="keyword">end</span>
0088 <span class="keyword">if</span> iscell(metKnown)
0089     metK = findMetIDs(model,metKnown);
0090 <span class="keyword">else</span>
0091     metK = metKnown;
0092 <span class="keyword">end</span>
0093 <span class="keyword">if</span> any(metK == 0) 
0094     <span class="keyword">if</span> iscell(metKnown)
0095         error(<span class="string">'%s in metKnown is not in the model.'</span>, metKnown{find(metK==0,1)});
0096     <span class="keyword">else</span>
0097         error(<span class="string">'metKnown index must be positive integer.'</span>)
0098     <span class="keyword">end</span>
0099 <span class="keyword">end</span>
0100 metKform = cellfun(@isempty,model.metFormulas(metK));
0101 <span class="keyword">if</span> any(metKform)
0102     warning(<span class="string">'Some mets in metKnown do not have formulas in the model. Ignore them.'</span>);
0103 <span class="keyword">end</span>
0104 <span class="comment">%All formulas must be in the form of e.g. Abc2Bcd1. Elements are</span>
0105 <span class="comment">%represented by one capital letter followed by lower case letter or</span>
0106 <span class="comment">%underscore, followed by a number for the stoichiometry. No brackets or</span>
0107 <span class="comment">%other symbols allowed.</span>
0108 [metK,metKform] = deal(metK(~metKform), model.metFormulas(metK(~metKform)));
0109 re = regexp(metKform,<span class="string">'[A-Z][a-z_]*(\-?\d+\.?\d*)?'</span>,<span class="string">'match'</span>);
0110 re = cellfun(@(x) strjoin(x,<span class="string">''</span>),re,<span class="string">'UniformOutput'</span>,false);
0111 goodForm = strcmp(strtrim(re), strtrim(metKform));
0112 <span class="keyword">if</span> ~all(goodForm)
0113     goodForm = find(~goodForm,1);
0114     error(<span class="string">'%s has an invalid formula %s\n'</span>,metKnown{goodForm},metKform{goodForm});
0115 <span class="keyword">end</span>
0116 <span class="comment">% [ynF,idF] = ismember(metFill,metK);</span>
0117 <span class="comment">% if ~all(ynF)</span>
0118 <span class="comment">%     error('''%s'' in ''metFill'' is not in ''metKnown''.',strjoin(model.mets(metFill(~ynF)),''', '''));</span>
0119 <span class="comment">% end</span>
0120 <span class="comment">%% minimum inconsistency</span>
0121 <span class="comment">%formulas for known metabolites</span>
0122 [~,eleK,metEleK] = <a href="../MatlabCobraToolbox/auxiliary_functions/checkEleBalance.html" class="code" title="function [EleBal, element, metEle] = checkEleBalance(model, element, metEle,selfCall)">checkEleBalance</a>(metKform);
0123 <span class="comment">%formulas for filling metabolites</span>
0124 [~,eleK,metEleF] = <a href="../MatlabCobraToolbox/auxiliary_functions/checkEleBalance.html" class="code" title="function [EleBal, element, metEle] = checkEleBalance(model, element, metEle,selfCall)">checkEleBalance</a>(metFill, eleK);
0125 <span class="keyword">if</span> numel(eleK) &gt; size(metEleK,2)
0126     metEleK = [metEleK, zeros(size(metEleK,1), numel(eleK) - size(metEleK,2))];
0127 <span class="keyword">end</span>
0128 eleCh = strcmp(eleK,<span class="string">'Charge'</span>);
0129 m = size(model.S,1);
0130 nE = numel(eleK);
0131 mK = numel(metK);
0132 mU = m - mK;
0133 mF = numel(metFill);
0134 metU = setdiff((1:m)',metK);
0135 nR = numel(rxnC);
0136 nameM = strcat(repmat(model.mets(metU), nE,1),<span class="string">'_'</span>, reshape(repmat(eleK(:)',mU,1),nE*mU,1));
0137 nameR = strcat(repmat(model.rxns(rxnC), nE,1),<span class="string">'_'</span>, reshape(repmat(eleK(:)',nR,1),nE*nR,1));
0138 <span class="keyword">if</span> mF &gt; 0
0139     nameF = strcat(repmat(metFill(:), nR,1),<span class="string">'_'</span>, reshape(repmat(model.rxns(rxnC)',mF,1),mF*nR,1));
0140 <span class="keyword">end</span>
0141 LP = Cplex();
0142 <span class="comment">%n_ik, stoichoimetry for element k in met i</span>
0143 LP.addCols(zeros(mU*nE,1),[],zeros(mU*nE,1),inf(mU*nE,1),[],char(nameM));
0144 <span class="keyword">if</span> any(eleCh)
0145     <span class="comment">%if charge is in the formula, allow negative charges</span>
0146     eleChK = find(eleCh);
0147     LP.Model.lb((mU*(eleChK-1) + 1):(mU*eleChK)) = -inf;
0148 <span class="keyword">end</span>
0149 <span class="comment">%x^+_jk, positive inconsistency of element k in reaction j</span>
0150 LP.addCols(1000*ones(nR*nE,1),[],zeros(nR*nE,1),inf(nR*nE,1),[],char(strcat(nameR,<span class="string">'_pos'</span>)));
0151 <span class="comment">%x^-_jk, negative inconsistency of element k in reaction j</span>
0152 LP.addCols(1000*ones(nR*nE,1),[],zeros(nR*nE,1),inf(nR*nE,1),[],char(strcat(nameR,<span class="string">'_neg'</span>)));
0153 <span class="keyword">if</span> mF &gt; 0
0154     <span class="comment">%z^+_ij, mets for filling inconsistency</span>
0155     LP.addCols(0.1*ones(nR*mF,1),[],zeros(nR*mF,1),inf(nR*mF,1),[],char(strcat(nameF,<span class="string">'_pos'</span>)));
0156     <span class="comment">%z^-_ij, mets for filling inconsistency</span>
0157     LP.addCols(0.1*ones(nR*mF,1),[],zeros(nR*mF,1),inf(nR*mF,1),[],char(strcat(nameF,<span class="string">'_neg'</span>)));
0158 <span class="keyword">end</span>
0159 <span class="comment">%RHS</span>
0160 b = -model.S(metK,rxnC)' * metEleK;
0161 b = b(:);
0162 <span class="comment">%constraint matrix</span>
0163 [row,col,entry] = find(model.S(metU,rxnC)');
0164 row = repmat(row(:),nE,1)+reshape(repmat(0:nR:nR*(nE-1),numel(row),1),numel(row)*nE,1);
0165 col = repmat(col(:),nE,1)+reshape(repmat(0:mU:mU*(nE-1),numel(col),1),numel(col)*nE,1);
0166 entry = repmat(entry,nE,1);
0167 row2 = reshape(repmat(1:nR*nE, mF, 1),nR*nE*mF,1);
0168 col2 = repmat((1:mF*nR)',nE,1);
0169 entry2 = reshape(repmat(metEleF,nR,1),nR*nE*mF,1);
0170 A = [sparse(row,col,entry,nR*nE,mU*nE), <span class="keyword">...</span><span class="comment"> % sum(i, S_ij * n_ie)</span>
0171     sparse(1:nR*nE,1:nR*nE,ones(nR*nE,1),nR*nE,nR*nE), <span class="keyword">...</span><span class="comment"> % + x^+_je</span>
0172     sparse(1:nR*nE,1:nR*nE,-ones(nR*nE,1),nR*nE,nR*nE), <span class="keyword">...</span><span class="comment"> % - x^-_je</span>
0173     sparse(row2,col2,entry2), -sparse(row2,col2,entry2)]; <span class="comment">% + z^+_ij * n_ie - z^-_ij * n_ie</span>
0174 <span class="comment">% S_unknown' n_unknown = - S_known' * n_known</span>
0175 LP.addRows(b, A, b, char(strcat(nameR,<span class="string">'_bal'</span>)));
0176 <span class="comment">%Handle parameters</span>
0177 cobraParam = struct();
0178 cobraParamList = {<span class="string">'feasTol'</span>,<span class="string">'optTol'</span>};
0179 CplexParamList = {<span class="string">'feasibility'</span>,<span class="string">'optimality'</span>};
0180 [cobraParam.feasTol, cobraParam.optTol] = getCobraSolverParams(<span class="string">'LP'</span>,cobraParamList, param);
0181 <span class="keyword">for</span> j = 1:numel(CplexParamList)
0182     <span class="keyword">if</span> isfield(param,CplexParamList{j})
0183         cobraParam.(cobraParamList{j}) = param.(CplexParamList{j});
0184     <span class="keyword">elseif</span> isfield(param,<span class="string">'simplex'</span>) &amp;&amp; isfield(param.simplex,CplexParamList{j})
0185         cobraParam.(cobraParamList{j}) = param.simplex.(CplexParamList{j});
0186     <span class="keyword">elseif</span> isfield(param,<span class="string">'simplex'</span>) &amp;&amp; isfield(param.simplex,<span class="string">'tolerances'</span>) &amp;&amp; isfield(param.simplex.tolerances,CplexParamList{j})
0187         cobraParam.(cobraParamList{j}) = param.simplex.tolerances.(CplexParamList{j});
0188     <span class="keyword">else</span>
0189         param.simplex.tolerances.(CplexParamList{j}) = cobraParam.(cobraParamList{j});
0190     <span class="keyword">end</span>
0191 <span class="keyword">end</span>
0192 LP = <a href="../MatlabCobraToolbox/auxiliary_functions/setCplexParam.html" class="code" title="function LP = setCplexParam(LP, solverParam,verbFlag)">setCplexParam</a>(LP,param);
0193 feasTol = LP.Param.simplex.tolerances.feasibility.Cur;
0194 <span class="comment">%Solve</span>
0195 LP.solve;
0196 <span class="comment">%manually check feasibility</span>
0197 feas = <a href="../MatlabCobraToolbox/auxiliary_functions/checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP);
0198 
0199 <span class="keyword">if</span> ~(feas &lt;= feasTol)
0200     <span class="keyword">if</span> isfield(LP.Solution,<span class="string">'x'</span>)
0201         metEle = zeros(numel(model.mets),numel(eleK));
0202         metEle(metK,:) = metEleK;
0203         metEle(metU,:) = reshape(LP.Solution.x(1:mU*nE),mU,nE);
0204         rxnBal = metEle' * model.S;
0205         S_fill = sparse(repmat((1:mF)',nR,1),reshape(repmat(rxnC(:)',mF,1),mF*nR,1), <span class="keyword">...</span>
0206             LP.Solution.x(((mU+nR*2)*nE+1):((mU+nR*2)*nE+nR*mF)) <span class="keyword">...</span>
0207             - LP.Solution.x(((mU+nR*2)*nE+nR*mF+1):((mU+nR*2)*nE+nR*mF*2)), <span class="keyword">...</span>
0208             mF, size(model.S,2));
0209         <span class="comment">% S_fill(metFill,rxnC) = reshape(LP.Solution.x(((mU+nR*2)*nE+1):((mU+nR*2)*nE+nR*mF*2)),mF,nR);</span>
0210     <span class="keyword">else</span>
0211         metEle = [];
0212         rxnBal = [];
0213         S_fill = [];
0214     <span class="keyword">end</span>
0215     ele = eleK;
0216     <span class="comment">%terminate if infeasible (should not happen)</span>
0217     fprint(<span class="string">'Infeasible during optimization for minimal inconsistency.'</span>);
0218     <span class="keyword">return</span>
0219 <span class="keyword">end</span>
0220 x = LP.Solution.x;
0221 
0222 <span class="comment">%% minimal formulas</span>
0223 <span class="comment">%bound the inconsistency with the above solution</span>
0224 ind = (mU*nE+1):((mU+2*nR)*nE);
0225 LP.Model.ub(ind(x(ind) &lt;= 0)) = 0;
0226 LP.Model.ub(ind(x(ind) &gt; 0)) = x(ind(x(ind) &gt; 0)) * (1 + 1e-12);
0227 LP.Model.lb(ind(x(ind) &gt; feasTol)) = x(ind(x(ind) &gt; feasTol)) * (1 - 1e-12);
0228 ind = ((mU+2*nR)*nE+1):((mU+2*nR)*nE+mF*nR*2);
0229 LP.Model.ub(ind(x(ind) &lt;= 0)) = 0;
0230 LP.Model.ub(ind(x(ind) &gt; 0)) = x(ind(x(ind) &gt; 0)) * (1 + 1e-12);
0231 LP.Model.lb(ind(x(ind) &gt; feasTol)) = x(ind(x(ind) &gt; feasTol)) * (1 - 1e-12);
0232 <span class="comment">%Change objective</span>
0233 LP.Model.obj(:) = 0;
0234 LP.Model.obj(1:mU*nE) = 1;
0235 <span class="keyword">if</span> any(eleCh)
0236     <span class="comment">%decompose charge variables into +ve and -ve part if exist</span>
0237     orderCh = find(eleCh);
0238     LP.Model.obj((mU*(orderCh - 1) + 1):(mU*orderCh)) = 0;
0239     LP.addCols(ones(mU,1),[],zeros(mU,1),inf(mU,1),[],char(strcat(model.mets(metU),<span class="string">'_charge+'</span>)));
0240     LP.addCols(ones(mU,1),[],zeros(mU,1),inf(mU,1),[],char(strcat(model.mets(metU),<span class="string">'_charge-'</span>)));
0241     LP.addRows(zeros(mU,1),<span class="keyword">...</span>
0242         [sparse(mU,mU*(orderCh - 1)), sparse(1:mU,1:mU,ones(mU,1),mU,mU), <span class="keyword">...</span>
0243         sparse(mU, mU*(nE-orderCh) + nR*2*nE), sparse(mU, mF*nR*2), <span class="keyword">...</span>
0244         sparse(1:mU,1:mU,-ones(mU,1),mU,mU),sparse(1:mU,1:mU,ones(mU,1),mU,mU)],<span class="keyword">...</span>
0245         zeros(mU,1),char(strcat(model.mets(metU),<span class="string">'_charge_decomp'</span>)));
0246 <span class="keyword">end</span>
0247 <span class="comment">%solve</span>
0248 LP.solve;
0249 <span class="comment">%check feasibility</span>
0250 feas = <a href="../MatlabCobraToolbox/auxiliary_functions/checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP);
0251 metEle = zeros(numel(model.mets),numel(eleK));
0252 metEle(metK,:) = metEleK;
0253 <span class="keyword">if</span> feas &lt;= feasTol
0254     metEle(metU,:) = reshape(LP.Solution.x(1:mU*nE),mU,nE);
0255     S_fill = sparse(repmat((1:mF)',nR,1),reshape(repmat(rxnC(:)',mF,1),mF*nR,1), <span class="keyword">...</span>
0256             LP.Solution.x(((mU+nR*2)*nE+1):((mU+nR*2)*nE+nR*mF)) <span class="keyword">...</span>
0257             - LP.Solution.x(((mU+nR*2)*nE+nR*mF+1):((mU+nR*2)*nE+nR*mF*2)), <span class="keyword">...</span>
0258             mF, size(model.S,2));
0259 <span class="keyword">else</span>
0260     <span class="comment">%use the previous solution if currectly infeasible</span>
0261     metEle(metU,:) = reshape(x(1:mU*nE),mU,nE);
0262     fprint(<span class="string">'Infeasible during optimization for minimal formulas.'</span>);
0263 <span class="keyword">end</span>
0264 
0265 
0266 <span class="comment">%% find conserved moieties</span>
0267 <span class="keyword">if</span> nargin &lt; 4 || isempty(findCM)
0268     findCM = true;
0269 <span class="keyword">end</span>
0270 cont = true;
0271 <span class="keyword">if</span> ischar(findCM) &amp;&amp; strcmpi(findCM,<span class="string">'efmtool'</span>)
0272     <span class="comment">%use EFMtool</span>
0273     pathEFM = which(<span class="string">'CalculateFluxModes.m'</span>);
0274     <span class="keyword">if</span> isempty(pathEFM)
0275         warning(<span class="string">'EFMtool not in Matlab path. Use rational basis.'</span>);
0276     <span class="keyword">else</span>
0277         dirEFM = strsplit(pathEFM,filesep);
0278         dirEFM = strjoin(dirEFM(1:end-1),filesep);
0279         dirCur = pwd;
0280         cd(dirEFM);
0281         <span class="comment">%will very probably fail due to lack of memory if there are many</span>
0282         <span class="comment">%dead end metabolites, may add code to remove deadend mets first</span>
0283         <span class="comment">%         [~,removedMets] = removeDeadEnds(model);</span>
0284         <span class="comment">%         metDead = findMetIDs(model,removedMets);</span>
0285         N = CalculateFluxModes(full(model.S'),zeros(numel(model.mets),1));
0286         N = N.efms;
0287         cd(dirCur);
0288         cont = false;
0289     <span class="keyword">end</span>
0290     findCM = true;
0291 <span class="keyword">end</span>
0292 <span class="keyword">if</span> cont
0293     <span class="keyword">if</span> size(findCM,1) == numel(model.mets)
0294         <span class="comment">%input is the null space matrix / set of extreme rays</span>
0295         N = findCM;
0296         findCM = true;
0297     <span class="keyword">elseif</span> numel(findCM) == 1 &amp;&amp; findCM
0298         N = null(full(model.S'),<span class="string">'r'</span>);
0299     <span class="keyword">else</span>
0300         N = [];
0301     <span class="keyword">end</span>
0302 <span class="keyword">end</span>
0303 <span class="keyword">if</span> findCM
0304     fprintf(<span class="string">'Find conserved moieties...\n'</span>);
0305     
0306     <span class="comment">%clear close-to-zero values</span>
0307     N(abs(N) &lt; 1e-8) = 0;
0308     N = sparse(N);
0309     <span class="comment">%true generic conserved moieties, positive and not involving known mets</span>
0310     Ncm = N(:,~any(N &lt; 0, 1) &amp; ~any(N(metK,:),1));
0311     <span class="comment">%add them into formulas</span>
0312     metEle = [metEle, Ncm];
0313     ele = [eleK(:); cell(size(Ncm,2),1)];
0314     j2 = 1;
0315     <span class="keyword">for</span> j = 1:size(Ncm,2)
0316         <span class="keyword">while</span> any(strcmp(ele(1:nE),[<span class="string">'Conserve_'</span> <a href="#_sub1" class="code" title="subfunction s = num2alpha(index,charSet)">num2alpha</a>(j2)]))
0317             j2 = j2 + 1;
0318         <span class="keyword">end</span>
0319         ele{nE+j} = [<span class="string">'Conserve_'</span> <a href="#_sub1" class="code" title="subfunction s = num2alpha(index,charSet)">num2alpha</a>(j2)];
0320         j2 = j2 + 1;
0321     <span class="keyword">end</span>
0322 <span class="keyword">else</span>
0323     ele = eleK(:);
0324 <span class="keyword">end</span>
0325 rxnBal = metEle' * model.S;
0326 model.metFormulas = <a href="../MatlabCobraToolbox/auxiliary_functions/convertMatrixFormulas.html" class="code" title="function metForm = convertMatrixFormulas(element, metEle, dMax)">convertMatrixFormulas</a>(ele,metEle,10);
0327 <span class="keyword">if</span> nameCM &gt; 0 &amp;&amp; findCM ~= 0
0328     <span class="comment">%manually name conserved moieties</span>
0329     ele0 = ele;
0330     nDefault = 0;
0331     nCM = size(Ncm,2);
0332     eleDel = false(nE + nCM, 1);
0333     <span class="keyword">if</span> nameCM == 1
0334         <span class="comment">%get dead end metatbolites</span>
0335         [~,removedMets] = removeDeadEnds(model);
0336         metDead = findMetIDs(model,removedMets);
0337     <span class="keyword">end</span>
0338     <span class="keyword">for</span> j = 1:nCM
0339         fprintf(<span class="string">'\n'</span>);
0340         writeCell2Text([model.mets(Ncm(:,j)~=0),model.metFormulas(Ncm(:,j)~=0),<span class="keyword">...</span>
0341             model.metNames(Ncm(:,j)~=0)]);
0342         fprintf(<span class="string">'\n'</span>);
0343         <span class="keyword">if</span> nameCM == 1 &amp;&amp; any(Ncm(metDead,j),1)
0344             <span class="comment">%use the defaulted for dead end mets</span>
0345             nDefault = nDefault + 1;
0346             ele{nE+j} = ele0{nE + nDefault};
0347         <span class="keyword">else</span>
0348             cont = false;
0349             <span class="keyword">while</span> true
0350                 s = input([<span class="string">'Enter the formula for the conserved moiety (e.g. OHRab_cd):\n'</span>,<span class="keyword">...</span>
0351                     <span class="string">'(hit return to use default name ''Conserve_xxx'')\n'</span>],<span class="string">'s'</span>);
0352                 <span class="keyword">if</span> isempty(s)
0353                     <span class="comment">%use the defaulted</span>
0354                     nDefault = nDefault + 1;
0355                     ele{nE+j} = ele0{nE + nDefault};
0356                     <span class="keyword">break</span>
0357                 <span class="keyword">end</span>
0358                 re = regexp(s,<span class="string">'[A-Z][a-z_]*(\-?\d+\.?\d*)?'</span>,<span class="string">'match'</span>);
0359                 <span class="keyword">if</span> strcmp(strjoin(re,<span class="string">''</span>),s)
0360                     <span class="comment">%manual input formula, continue to checking</span>
0361                     cont = true;
0362                     <span class="keyword">break</span>
0363                 <span class="keyword">end</span>
0364             <span class="keyword">end</span>
0365             <span class="keyword">if</span> cont
0366                 <span class="comment">%get the matrix for the input formula</span>
0367                 nEnew = numel(ele) - nE - nCM;
0368                 [~, eleJ, metEleJ] = <a href="../MatlabCobraToolbox/auxiliary_functions/checkEleBalance.html" class="code" title="function [EleBal, element, metEle] = checkEleBalance(model, element, metEle,selfCall)">checkEleBalance</a>(s,ele([1:nE, (nE+nCM+1):end]));
0369                 metEle(:,[1:nE, (nE+nCM+1):end]) = metEle(:,[1:nE, (nE+nCM+1):end])<span class="keyword">...</span>
0370                         + metEle(:,nE+j) * metEleJ(1,1:(nE+nEnew));
0371                 <span class="keyword">if</span> numel(eleJ) &gt; nE + nEnew
0372                     <span class="comment">%there are new elements</span>
0373                     ele = [ele(:); eleJ((numel(ele)-nCM+1):end)];
0374                     metEle = [metEle, metEle(:,nE+j) * metEleJ(1,(nE+nEnew+1):end)];
0375                 <span class="keyword">end</span>
0376 <span class="comment">%                 [ynJ,idJ] = ismember(eleJ,ele(1:nE));</span>
0377 <span class="comment">%                 if any(ynJ)</span>
0378 <span class="comment">%                     metEle(:,idJ(ynJ)) = metEle(:,idJ(ynJ)) + metEle(:,nE+j) * metEleJ(1,ynJ);</span>
0379 <span class="comment">%                 end</span>
0380 <span class="comment">%                 eleJ = eleJ(~ynJ);</span>
0381 <span class="comment">%                 metEleJ = metEleJ(1,~ynJ);</span>
0382 <span class="comment">%                 if numel(ele) &gt; nE + nCM</span>
0383 <span class="comment">%                     [ynJ,idJ] = ismember(eleJ,ele(nE+nCM+1:end));</span>
0384 <span class="comment">%                     if any(ynJ)</span>
0385 <span class="comment">%                         metEle(:,nE+nCM+idJ(ynJ)) = metEle(:,nE+nCM+idJ(ynJ)) ...</span>
0386 <span class="comment">%                             + metEle(:,nE+j) * metEleJ(1,ynJ);</span>
0387 <span class="comment">%                     end</span>
0388 <span class="comment">%                     eleJ = eleJ(~ynJ);</span>
0389 <span class="comment">%                     metEleJ = metEleJ(1,~ynJ);</span>
0390 <span class="comment">%                 end</span>
0391 <span class="comment">%                 if ~isempty(eleJ)</span>
0392 <span class="comment">%                     ele = [ele(:);eleJ(:)];</span>
0393 <span class="comment">%                     metEle = [metEle, metEleJ];</span>
0394 <span class="comment">%                 end</span>
0395                 eleDel(nE + j) = true;
0396             <span class="keyword">end</span>
0397         <span class="keyword">end</span>
0398     <span class="keyword">end</span>
0399     <span class="comment">%del defaulted but replaced columns</span>
0400     <span class="keyword">if</span> any(eleDel)
0401         eleDel = find(eleDel);
0402         ele(eleDel) = [];
0403         metEle(:,eleDel) = [];
0404     <span class="keyword">end</span>
0405     <span class="comment">%1:nE              : real elements</span>
0406     <span class="comment">%nE+1:nE+nDefault  : default generic elements (Conserve_xxx)</span>
0407     <span class="comment">%nE+nDeafult+1:end : generic element by user's input</span>
0408     <span class="comment">%Change if names of default generic elements are mixed up with user</span>
0409     <span class="comment">%input</span>
0410     j0 = 0;
0411     <span class="keyword">for</span> j = 1:nDefault
0412         j0 = j0 + 1;
0413         nameJ = [<span class="string">'Conserve_'</span> <a href="#_sub1" class="code" title="subfunction s = num2alpha(index,charSet)">num2alpha</a>(j0)];
0414         <span class="keyword">while</span> any(strcmp(ele([1:nE, nE+nDefault+1:end]),nameJ))
0415             j0 = j0 + 1;
0416             nameJ = [<span class="string">'Conserve_'</span> <a href="#_sub1" class="code" title="subfunction s = num2alpha(index,charSet)">num2alpha</a>(j0)];
0417         <span class="keyword">end</span>
0418         ele{nE+j} = nameJ;
0419     <span class="keyword">end</span>
0420 <span class="keyword">end</span>
0421 model.metFormulas = <a href="../MatlabCobraToolbox/auxiliary_functions/convertMatrixFormulas.html" class="code" title="function metForm = convertMatrixFormulas(element, metEle, dMax)">convertMatrixFormulas</a>(ele,metEle,10);
0422 metCompute = [model.mets(metU) model.metFormulas(metU)];
0423 <span class="keyword">end</span>
0424 
0425 <a name="_sub1" href="#_subfunctions" class="code">function s = num2alpha(index,charSet)</a>
0426 <span class="comment">%s = num2alpha(j,charSet)</span>
0427 <span class="comment">%Given a nonzero integer j and a character set charSet, convert j into</span>
0428 <span class="comment">%a string formed from the characters in charSet having order j.</span>
0429 <span class="comment">%'charSet' defaulted to be '_abcdefghijklmnopqrstuvwxyz' in which '_' acts</span>
0430 <span class="comment">%like 0 and 'z' acts like the largest digit 9 in decimal expression</span>
0431 <span class="comment">%e.g. num2slpha(0) is '_' , num2slpha(1) is 'a', num2slpha(27^2) is 'a__'</span>
0432 <span class="comment">%</span>
0433 <span class="keyword">if</span> nargin &lt; 2
0434     charSet = [<span class="string">'_'</span> char(97:122)];
0435 <span class="keyword">end</span>
0436 <span class="keyword">if</span> numel(index) &gt; 1
0437     s = cell(numel(index),1);
0438     <span class="keyword">for</span> j = 1:numel(index)
0439         s{j} = <a href="#_sub1" class="code" title="subfunction s = num2alpha(index,charSet)">num2alpha</a>(index(j),charSet);
0440     <span class="keyword">end</span>
0441     <span class="keyword">return</span>
0442 <span class="keyword">end</span>
0443 N = length(charSet);
0444 s = <span class="string">''</span>;
0445 k = floor(index/N);
0446 <span class="keyword">while</span> k &gt; 0
0447     s = [s charSet(index - k*N + 1)];
0448     index = k;
0449     k = floor(index/N);
0450 <span class="keyword">end</span>
0451 s = [charSet(mod(index,N) + 1) s];
0452 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Tue 09-May-2017 12:37:40 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2003</address>
</body>
</html>