<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of computeFormulasFillMets</title>
  <meta name="keywords" content="computeFormulasFillMets">
  <meta name="description" content="Compute the chemical formulas of the unknown metabolites">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<!-- menu.html MatlabCobraToolbox -->
<h1>computeFormulasFillMets
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>Compute the chemical formulas of the unknown metabolites</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [model,metCompute,S_fill,rxnBal,ele,metEle,N,LP] = computeFormulasFillMets(model,metKnown,rxns,metFill,findCM,nameCM,param) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Compute the chemical formulas of the unknown metabolites 
 using a set of metabolites with known formulae and a set of reactions.
 To include charge balance in the computation, simply in all formulas, add
 e.g. 'Charge2' for charge +2 or 'Charge-1' for charge -1. 'C' must be
 capitalized and 'harge' must be in lower case.
 The minimum conflict is found by allowing filling up by metFill (e.g. proton) in the reaction stoichiometry

 [model,metCompute,S_fill,rxnBal,ele,metEle,N] = computeFormulasFillMets(model,metKnown,rxns,metFill,findCM);
 Input:
   model:              COBRA model
   metKnown:           known metabolites (character array or IDs)
   rxns:               the set of reactions for inferring formulae (character array or IDs)
   metFill:            the chemical formulas for compounds for freely filling the
                       imbalance, e.g. {'HCharge1', 'H2O'}
   findCM = 'efmtool': find conserved moieties using EFMtool (most comprehensive, 
                       but computational cost may be high.)  
                       (default, if EFMtool not in path, switch to rational basis)
   findCM = true  :    find conserved moieties and add into formulas using the rational basis of model.S'
   findCM = N     :    directly supply the rational basis for N(S') or 
                       the set of extreme rays for {n | n * S = 0, n &gt;= 0}
   findCM = false :    not to find conserved moieties and return minimal formulas
 Output:
   model:          COBRA model with updated formulas
   metCompute:     M_unknown x 2 array of cell with [mets | computed formulas]
   S_fill:         mF x n matrix representing the adjustment of the S-matrix 
                   if you supply mF mets as 'metFill'
   rxnBal:         N by E matrix for the elemental balance of rxns, the ij-th
                   entry is the imbalance of the i-th rxn regarding the j-th element in 'ele'
   ele             elements corresponding to the row of rxnBal, as well as
                   to the coloumn of metEle
   metEle:         chemical formulas in a M by E matrix.
   N:              the extreme ray or rational null space matrix</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="../MatlabCobraToolbox/auxiliary_functions/checkEleBalance.html" class="code" title="function [EleBal, element, metEle] = checkEleBalance(model, element, metEle,selfCall)">checkEleBalance</a>	Check the elemental balance of the reactions in the COBRA mode 'model'.</li><li><a href="../MatlabCobraToolbox/auxiliary_functions/checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>	Check the feasibility of a solution given a COBRA model structure or a CPLEX dynamic object and a solution</li><li><a href="../MatlabCobraToolbox/auxiliary_functions/convertMatrixFormulas.html" class="code" title="function metForm = convertMatrixFormulas(element, metEle, dMax)">convertMatrixFormulas</a>	Convert the matrix form of the chemical formulae into string form</li><li><a href="../MatlabCobraToolbox/auxiliary_functions/setCplexParam.html" class="code" title="function LP = setCplexParam(LP, solverParam,verbFlag)">setCplexParam</a>	Set the parameters of the CPLEX object according to the structure solverParam</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function s = num2alpha(index,charSet)</a></li></ul>
<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [model,metCompute,S_fill,rxnBal,ele,metEle,N,LP] = computeFormulasFillMets(model,metKnown,rxns,metFill,findCM,nameCM,param)</a>
0002 <span class="comment">% Compute the chemical formulas of the unknown metabolites</span>
0003 <span class="comment">% using a set of metabolites with known formulae and a set of reactions.</span>
0004 <span class="comment">% To include charge balance in the computation, simply in all formulas, add</span>
0005 <span class="comment">% e.g. 'Charge2' for charge +2 or 'Charge-1' for charge -1. 'C' must be</span>
0006 <span class="comment">% capitalized and 'harge' must be in lower case.</span>
0007 <span class="comment">% The minimum conflict is found by allowing filling up by metFill (e.g. proton) in the reaction stoichiometry</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% [model,metCompute,S_fill,rxnBal,ele,metEle,N] = computeFormulasFillMets(model,metKnown,rxns,metFill,findCM);</span>
0010 <span class="comment">% Input:</span>
0011 <span class="comment">%   model:              COBRA model</span>
0012 <span class="comment">%   metKnown:           known metabolites (character array or IDs)</span>
0013 <span class="comment">%   rxns:               the set of reactions for inferring formulae (character array or IDs)</span>
0014 <span class="comment">%   metFill:            the chemical formulas for compounds for freely filling the</span>
0015 <span class="comment">%                       imbalance, e.g. {'HCharge1', 'H2O'}</span>
0016 <span class="comment">%   findCM = 'efmtool': find conserved moieties using EFMtool (most comprehensive,</span>
0017 <span class="comment">%                       but computational cost may be high.)</span>
0018 <span class="comment">%                       (default, if EFMtool not in path, switch to rational basis)</span>
0019 <span class="comment">%   findCM = true  :    find conserved moieties and add into formulas using the rational basis of model.S'</span>
0020 <span class="comment">%   findCM = N     :    directly supply the rational basis for N(S') or</span>
0021 <span class="comment">%                       the set of extreme rays for {n | n * S = 0, n &gt;= 0}</span>
0022 <span class="comment">%   findCM = false :    not to find conserved moieties and return minimal formulas</span>
0023 <span class="comment">% Output:</span>
0024 <span class="comment">%   model:          COBRA model with updated formulas</span>
0025 <span class="comment">%   metCompute:     M_unknown x 2 array of cell with [mets | computed formulas]</span>
0026 <span class="comment">%   S_fill:         mF x n matrix representing the adjustment of the S-matrix</span>
0027 <span class="comment">%                   if you supply mF mets as 'metFill'</span>
0028 <span class="comment">%   rxnBal:         N by E matrix for the elemental balance of rxns, the ij-th</span>
0029 <span class="comment">%                   entry is the imbalance of the i-th rxn regarding the j-th element in 'ele'</span>
0030 <span class="comment">%   ele             elements corresponding to the row of rxnBal, as well as</span>
0031 <span class="comment">%                   to the coloumn of metEle</span>
0032 <span class="comment">%   metEle:         chemical formulas in a M by E matrix.</span>
0033 <span class="comment">%   N:              the extreme ray or rational null space matrix</span>
0034 
0035 <span class="comment">%[model,metCompute,S_fill,rxnBal,ele,metEle,N] = computeFormulasFillMets(model,metKnown,rxns,metFill,findCM,nameCM);</span>
0036 <span class="comment">% nameCM = 0 the program assigns default names for conserved moieties</span>
0037 <span class="comment">%            (Conserve_a, Conserve_b, ...)</span>
0038 <span class="comment">% nameCM = 1 to name true conserved moieties interactively (exclude dead end mets).</span>
0039 <span class="comment">% nameCM = 2 to name all (including dead end)</span>
0040 <span class="comment">%</span>
0041 <span class="comment">% [model,metCompute,rxnBal,ele,metEle,N,LP] = computeFormulas(...)</span>
0042 <span class="comment">% Return also the CPLEX optimization object 'LP'</span>
0043 
0044 <span class="comment">%check mets with formulas that need to be transformed</span>
0045 <span class="comment">%form0 = model.metFormulas;</span>
0046 <span class="keyword">if</span> ~isfield(model,<span class="string">'metFormulas'</span>)
0047     error(<span class="string">'model does not have the field ''metFormulas.'''</span>)
0048 <span class="keyword">end</span>
0049 <span class="keyword">if</span> nargin &lt; 7 || isempty(param) 
0050     param = struct();
0051 <span class="keyword">end</span>
0052 <span class="keyword">if</span> nargin &lt; 6 || isempty(nameCM)
0053     nameCM = 0;
0054 <span class="keyword">end</span>
0055 <span class="keyword">if</span> nargin &lt; 5 || isempty(findCM)
0056     findCM = <span class="string">'efmtool'</span>;
0057 <span class="keyword">end</span>
0058 <span class="keyword">if</span> nargin &lt; 4 || isempty(metFill)
0059     <span class="comment">%defaulted proton for filling imbalance</span>
0060     metFill = {<span class="string">'HCharge1'</span>};
0061 <span class="keyword">elseif</span> ischar(metFill)
0062     metFill = {metFill};
0063 <span class="keyword">end</span>
0064 <span class="keyword">if</span> nargin &lt; 3 || isempty(rxns)
0065     rxns = find(sum(model.S~=0,1) &gt; 1 &amp; (model.lb ~= 0 | model.ub ~= 0)');
0066 <span class="keyword">end</span>
0067 <span class="keyword">if</span> ischar(rxns)
0068     rxns = {rxns};
0069 <span class="keyword">end</span>
0070 <span class="keyword">if</span> iscell(rxns)
0071     rxnC = findRxnIDs(model,rxns);
0072 <span class="keyword">else</span>
0073     rxnC = rxns;
0074 <span class="keyword">end</span>
0075 <span class="keyword">if</span> any(rxnC == 0)
0076     <span class="keyword">if</span> iscell(rxns)
0077         error(<span class="string">'%s in rxns is not in the model.'</span>, rxns{find(rxnC==0,1)});
0078     <span class="keyword">else</span>
0079         error(<span class="string">'rxns index must be positive integer.'</span>)
0080     <span class="keyword">end</span>
0081 <span class="keyword">end</span>
0082 <span class="keyword">if</span> nargin &lt; 2 || isempty(metKnown)
0083     metKnown = model.mets(~cellfun(@isempty,model.metFormulas));
0084 <span class="keyword">end</span>
0085 <span class="keyword">if</span> ischar(metKnown)
0086     metKnown = {metKnown};
0087 <span class="keyword">end</span>
0088 <span class="keyword">if</span> iscell(metKnown)
0089     metK = findMetIDs(model,metKnown);
0090 <span class="keyword">else</span>
0091     metK = metKnown;
0092 <span class="keyword">end</span>
0093 <span class="keyword">if</span> any(metK == 0) 
0094     <span class="keyword">if</span> iscell(metKnown)
0095         error(<span class="string">'%s in metKnown is not in the model.'</span>, metKnown{find(metK==0,1)});
0096     <span class="keyword">else</span>
0097         error(<span class="string">'metKnown index must be positive integer.'</span>)
0098     <span class="keyword">end</span>
0099 <span class="keyword">end</span>
0100 metKform = cellfun(@isempty,model.metFormulas(metK));
0101 <span class="keyword">if</span> any(metKform)
0102     warning(<span class="string">'Some mets in metKnown do not have formulas in the model. Ignore them.'</span>);
0103 <span class="keyword">end</span>
0104 <span class="comment">%All formulas must be in the form of e.g. Abc2Bcd1. Elements are</span>
0105 <span class="comment">%represented by one capital letter followed by lower case letter or</span>
0106 <span class="comment">%underscore, followed by a number for the stoichiometry.</span>
0107 <span class="comment">%Brackets/parentheses are also supported.</span>
0108 [metK,metKform] = deal(metK(~metKform), model.metFormulas(metK(~metKform)));
0109 <span class="comment">%%Now handled by checkEleBalance</span>
0110 <span class="comment">% re = regexp(metKform,'[A-Z][a-z_]*(\-?\d+\.?\d*)?','match');</span>
0111 <span class="comment">% re = cellfun(@(x) strjoin(x,''),re,'UniformOutput',false);</span>
0112 <span class="comment">% goodForm = strcmp(strtrim(re), strtrim(metKform));</span>
0113 <span class="comment">% if ~all(goodForm)</span>
0114 <span class="comment">%     goodForm = find(~goodForm,1);</span>
0115 <span class="comment">%     error('%s has an invalid formula %s\n',metKnown{goodForm},metKform{goodForm});</span>
0116 <span class="comment">% end</span>
0117 
0118 <span class="comment">%% minimum inconsistency</span>
0119 <span class="comment">%formulas for known metabolites</span>
0120 [~,eleK,metEleK] = <a href="../MatlabCobraToolbox/auxiliary_functions/checkEleBalance.html" class="code" title="function [EleBal, element, metEle] = checkEleBalance(model, element, metEle,selfCall)">checkEleBalance</a>(metKform);
0121 <span class="comment">%formulas for filling metabolites</span>
0122 [~,eleK,metEleF] = <a href="../MatlabCobraToolbox/auxiliary_functions/checkEleBalance.html" class="code" title="function [EleBal, element, metEle] = checkEleBalance(model, element, metEle,selfCall)">checkEleBalance</a>(metFill, eleK);
0123 <span class="keyword">if</span> numel(eleK) &gt; size(metEleK,2)
0124     metEleK = [metEleK, zeros(size(metEleK,1), numel(eleK) - size(metEleK,2))];
0125 <span class="keyword">end</span>
0126 eleCh = strcmp(eleK,<span class="string">'Charge'</span>); <span class="comment">%index for charge coloumn</span>
0127 m = size(model.S,1); <span class="comment">%number of mets</span>
0128 nE = numel(eleK); <span class="comment">%number of elements</span>
0129 mK = numel(metK); <span class="comment">%number of known mets</span>
0130 mU = m - mK; <span class="comment">%number of unknown mets</span>
0131 mF = numel(metFill); <span class="comment">%number of filling mets</span>
0132 metU = setdiff((1:m)',metK); <span class="comment">%index for unknown mets</span>
0133 nR = numel(rxnC); <span class="comment">%number of reactions that should be mass balanced</span>
0134 <span class="comment">%variable name for the stoichiometry for each element of each met</span>
0135 nameM = strcat(repmat(model.mets(metU), nE,1),<span class="string">'_'</span>, reshape(repmat(eleK(:)',mU,1),nE*mU,1));
0136 <span class="comment">%constraint name for the balance of each element in each rxn</span>
0137 nameR = strcat(repmat(model.rxns(rxnC), nE,1),<span class="string">'_'</span>, reshape(repmat(eleK(:)',nR,1),nE*nR,1));
0138 <span class="keyword">if</span> mF &gt; 0
0139     <span class="comment">%variable name for each filling met for each rxn</span>
0140     nameF = strcat(repmat(metFill(:), nR,1),<span class="string">'_'</span>, reshape(repmat(model.rxns(rxnC)',mF,1),mF*nR,1));
0141 <span class="keyword">end</span>
0142 
0143 LP = Cplex();
0144 <span class="comment">%n_ik, stoichoimetry for element k in met i</span>
0145 LP.addCols(zeros(mU*nE,1),[],zeros(mU*nE,1),inf(mU*nE,1),[],char(nameM));
0146 <span class="keyword">if</span> any(eleCh)
0147     <span class="comment">%if charge is in the formula, allow negative charges</span>
0148     eleChK = find(eleCh);
0149     LP.Model.lb((mU*(eleChK-1) + 1):(mU*eleChK)) = -inf;
0150 <span class="keyword">end</span>
0151 <span class="comment">%x^+_jk, positive inconsistency of element k in reaction j</span>
0152 LP.addCols(1000*ones(nR*nE,1),[],zeros(nR*nE,1),inf(nR*nE,1),[],char(strcat(nameR,<span class="string">'_pos'</span>)));
0153 <span class="comment">%x^-_jk, negative inconsistency of element k in reaction j</span>
0154 LP.addCols(1000*ones(nR*nE,1),[],zeros(nR*nE,1),inf(nR*nE,1),[],char(strcat(nameR,<span class="string">'_neg'</span>)));
0155 <span class="keyword">if</span> mF &gt; 0
0156     <span class="comment">%z^+_ij, mets for filling inconsistency</span>
0157     LP.addCols(0.1*ones(nR*mF,1),[],zeros(nR*mF,1),inf(nR*mF,1),[],char(strcat(nameF,<span class="string">'_pos'</span>)));
0158     <span class="comment">%z^-_ij, mets for filling inconsistency</span>
0159     LP.addCols(0.1*ones(nR*mF,1),[],zeros(nR*mF,1),inf(nR*mF,1),[],char(strcat(nameF,<span class="string">'_neg'</span>)));
0160 <span class="keyword">end</span>
0161 <span class="comment">%RHS</span>
0162 b = -model.S(metK,rxnC)' * metEleK;
0163 b = b(:);
0164 <span class="comment">%constraint matrix</span>
0165 [row,col,entry] = find(model.S(metU,rxnC)');
0166 row = repmat(row(:),nE,1)+reshape(repmat(0:nR:nR*(nE-1),numel(row),1),numel(row)*nE,1);
0167 col = repmat(col(:),nE,1)+reshape(repmat(0:mU:mU*(nE-1),numel(col),1),numel(col)*nE,1);
0168 entry = repmat(entry,nE,1);
0169 row2 = reshape(repmat(1:nR*nE, mF, 1),nR*nE*mF,1);
0170 col2 = repmat((1:mF*nR)',nE,1);
0171 entry2 = reshape(repmat(metEleF,nR,1),nR*nE*mF,1);
0172 A = [sparse(row,col,entry,nR*nE,mU*nE), <span class="keyword">...</span><span class="comment"> % sum(i, S_ij * n_ie)</span>
0173     sparse(1:nR*nE,1:nR*nE,ones(nR*nE,1),nR*nE,nR*nE), <span class="keyword">...</span><span class="comment"> % + x^+_je</span>
0174     sparse(1:nR*nE,1:nR*nE,-ones(nR*nE,1),nR*nE,nR*nE), <span class="keyword">...</span><span class="comment"> % - x^-_je</span>
0175     sparse(row2,col2,entry2), -sparse(row2,col2,entry2)]; <span class="comment">% + z^+_ij * n_ie - z^-_ij * n_ie</span>
0176 <span class="comment">% S_unknown' n_unknown = - S_known' * n_known</span>
0177 LP.addRows(b, A, b, char(strcat(nameR,<span class="string">'_bal'</span>)));
0178 <span class="comment">%Handle parameters</span>
0179 cobraParam = struct();
0180 cobraParamList = {<span class="string">'feasTol'</span>,<span class="string">'optTol'</span>};
0181 CplexParamList = {<span class="string">'feasibility'</span>,<span class="string">'optimality'</span>};
0182 [cobraParam.feasTol, cobraParam.optTol] = getCobraSolverParams(<span class="string">'LP'</span>,cobraParamList, param);
0183 <span class="keyword">for</span> j = 1:numel(CplexParamList)
0184     <span class="keyword">if</span> isfield(param,CplexParamList{j})
0185         cobraParam.(cobraParamList{j}) = param.(CplexParamList{j});
0186     <span class="keyword">elseif</span> isfield(param,<span class="string">'simplex'</span>) &amp;&amp; isfield(param.simplex,CplexParamList{j})
0187         cobraParam.(cobraParamList{j}) = param.simplex.(CplexParamList{j});
0188     <span class="keyword">elseif</span> isfield(param,<span class="string">'simplex'</span>) &amp;&amp; isfield(param.simplex,<span class="string">'tolerances'</span>) &amp;&amp; isfield(param.simplex.tolerances,CplexParamList{j})
0189         cobraParam.(cobraParamList{j}) = param.simplex.tolerances.(CplexParamList{j});
0190     <span class="keyword">else</span>
0191         param.simplex.tolerances.(CplexParamList{j}) = cobraParam.(cobraParamList{j});
0192     <span class="keyword">end</span>
0193 <span class="keyword">end</span>
0194 LP = <a href="../MatlabCobraToolbox/auxiliary_functions/setCplexParam.html" class="code" title="function LP = setCplexParam(LP, solverParam,verbFlag)">setCplexParam</a>(LP,param);
0195 feasTol = LP.Param.simplex.tolerances.feasibility.Cur;
0196 <span class="comment">%Solve</span>
0197 LP.solve;
0198 <span class="comment">%manually check feasibility</span>
0199 feas = <a href="../MatlabCobraToolbox/auxiliary_functions/checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP);
0200 
0201 <span class="keyword">if</span> ~(feas &lt;= feasTol)
0202     <span class="keyword">if</span> isfield(LP.Solution,<span class="string">'x'</span>)
0203         metEle = zeros(numel(model.mets),numel(eleK));
0204         metEle(metK,:) = metEleK;
0205         metEle(metU,:) = reshape(LP.Solution.x(1:mU*nE),mU,nE);
0206         rxnBal = metEle' * model.S;
0207         S_fill = sparse(repmat((1:mF)',nR,1),reshape(repmat(rxnC(:)',mF,1),mF*nR,1), <span class="keyword">...</span>
0208             LP.Solution.x(((mU+nR*2)*nE+1):((mU+nR*2)*nE+nR*mF)) <span class="keyword">...</span>
0209             - LP.Solution.x(((mU+nR*2)*nE+nR*mF+1):((mU+nR*2)*nE+nR*mF*2)), <span class="keyword">...</span>
0210             mF, size(model.S,2));
0211         <span class="comment">% S_fill(metFill,rxnC) = reshape(LP.Solution.x(((mU+nR*2)*nE+1):((mU+nR*2)*nE+nR*mF*2)),mF,nR);</span>
0212     <span class="keyword">else</span>
0213         metEle = [];
0214         rxnBal = [];
0215         S_fill = [];
0216     <span class="keyword">end</span>
0217     ele = eleK;
0218     <span class="comment">%terminate if infeasible (should not happen)</span>
0219     fprint(<span class="string">'Infeasible during optimization for minimal inconsistency.'</span>);
0220     <span class="keyword">return</span>
0221 <span class="keyword">end</span>
0222 x = LP.Solution.x;
0223 
0224 <span class="comment">%% minimal formulas</span>
0225 <span class="comment">%bound the inconsistency with the above solution</span>
0226 ind = (mU*nE+1):((mU+2*nR)*nE);
0227 LP.Model.ub(ind(x(ind) &lt;= 0)) = 0;
0228 LP.Model.ub(ind(x(ind) &gt; 0)) = x(ind(x(ind) &gt; 0)) * (1 + 1e-12);
0229 LP.Model.lb(ind(x(ind) &gt; feasTol)) = x(ind(x(ind) &gt; feasTol)) * (1 - 1e-12);
0230 ind = ((mU+2*nR)*nE+1):((mU+2*nR)*nE+mF*nR*2);
0231 LP.Model.ub(ind(x(ind) &lt;= 0)) = 0;
0232 LP.Model.ub(ind(x(ind) &gt; 0)) = x(ind(x(ind) &gt; 0)) * (1 + 1e-12);
0233 LP.Model.lb(ind(x(ind) &gt; feasTol)) = x(ind(x(ind) &gt; feasTol)) * (1 - 1e-12);
0234 <span class="comment">%Change objective</span>
0235 LP.Model.obj(:) = 0;
0236 LP.Model.obj(1:mU*nE) = 1;
0237 <span class="keyword">if</span> any(eleCh)
0238     <span class="comment">%decompose charge variables into +ve and -ve part if exist</span>
0239     orderCh = find(eleCh);
0240     LP.Model.obj((mU*(orderCh - 1) + 1):(mU*orderCh)) = 0;
0241     LP.addCols(ones(mU,1),[],zeros(mU,1),inf(mU,1),[],char(strcat(model.mets(metU),<span class="string">'_charge+'</span>)));
0242     LP.addCols(ones(mU,1),[],zeros(mU,1),inf(mU,1),[],char(strcat(model.mets(metU),<span class="string">'_charge-'</span>)));
0243     LP.addRows(zeros(mU,1),<span class="keyword">...</span>
0244         [sparse(mU,mU*(orderCh - 1)), sparse(1:mU,1:mU,ones(mU,1),mU,mU), <span class="keyword">...</span>
0245         sparse(mU, mU*(nE-orderCh) + nR*2*nE), sparse(mU, mF*nR*2), <span class="keyword">...</span>
0246         sparse(1:mU,1:mU,-ones(mU,1),mU,mU),sparse(1:mU,1:mU,ones(mU,1),mU,mU)],<span class="keyword">...</span>
0247         zeros(mU,1),char(strcat(model.mets(metU),<span class="string">'_charge_decomp'</span>)));
0248 <span class="keyword">end</span>
0249 <span class="comment">%solve</span>
0250 LP.solve;
0251 <span class="comment">%check feasibility</span>
0252 feas = <a href="../MatlabCobraToolbox/auxiliary_functions/checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP);
0253 metEle = zeros(numel(model.mets),numel(eleK));
0254 metEle(metK,:) = metEleK;
0255 <span class="keyword">if</span> feas &lt;= feasTol
0256     metEle(metU,:) = reshape(LP.Solution.x(1:mU*nE),mU,nE);
0257     S_fill = sparse(repmat((1:mF)',nR,1),reshape(repmat(rxnC(:)',mF,1),mF*nR,1), <span class="keyword">...</span>
0258             LP.Solution.x(((mU+nR*2)*nE+1):((mU+nR*2)*nE+nR*mF)) <span class="keyword">...</span>
0259             - LP.Solution.x(((mU+nR*2)*nE+nR*mF+1):((mU+nR*2)*nE+nR*mF*2)), <span class="keyword">...</span>
0260             mF, size(model.S,2));
0261 <span class="keyword">else</span>
0262     <span class="comment">%use the previous solution if currectly infeasible</span>
0263     metEle(metU,:) = reshape(x(1:mU*nE),mU,nE);
0264     fprint(<span class="string">'Infeasible during optimization for minimal formulas.'</span>);
0265 <span class="keyword">end</span>
0266 
0267 
0268 <span class="comment">%% find conserved moieties</span>
0269 <span class="keyword">if</span> nargin &lt; 4 || isempty(findCM)
0270     findCM = true;
0271 <span class="keyword">end</span>
0272 cont = true;
0273 <span class="keyword">if</span> ischar(findCM) &amp;&amp; strcmpi(findCM,<span class="string">'efmtool'</span>)
0274     <span class="comment">%use EFMtool</span>
0275     pathEFM = which(<span class="string">'CalculateFluxModes.m'</span>);
0276     <span class="keyword">if</span> isempty(pathEFM)
0277         warning(<span class="string">'EFMtool not in Matlab path. Use rational basis.'</span>);
0278     <span class="keyword">else</span>
0279         dirEFM = strsplit(pathEFM,filesep);
0280         dirEFM = strjoin(dirEFM(1:end-1),filesep);
0281         dirCur = pwd;
0282         cd(dirEFM);
0283         <span class="comment">%will very probably fail due to lack of memory if there are many</span>
0284         <span class="comment">%dead end metabolites, may add code to remove deadend mets first</span>
0285         <span class="comment">%         [~,removedMets] = removeDeadEnds(model);</span>
0286         <span class="comment">%         metDead = findMetIDs(model,removedMets);</span>
0287         N = CalculateFluxModes(full(model.S'),zeros(numel(model.mets),1));
0288         N = N.efms;
0289         cd(dirCur);
0290         cont = false;
0291     <span class="keyword">end</span>
0292     findCM = true;
0293 <span class="keyword">end</span>
0294 <span class="keyword">if</span> cont
0295     <span class="keyword">if</span> size(findCM,1) == numel(model.mets)
0296         <span class="comment">%input is the null space matrix / set of extreme rays</span>
0297         N = findCM;
0298         findCM = true;
0299     <span class="keyword">elseif</span> numel(findCM) == 1 &amp;&amp; findCM
0300         N = null(full(model.S'),<span class="string">'r'</span>);
0301     <span class="keyword">else</span>
0302         N = [];
0303     <span class="keyword">end</span>
0304 <span class="keyword">end</span>
0305 <span class="keyword">if</span> findCM
0306     fprintf(<span class="string">'Find conserved moieties...\n'</span>);
0307     
0308     <span class="comment">%clear close-to-zero values</span>
0309     N(abs(N) &lt; 1e-8) = 0;
0310     N = sparse(N);
0311     <span class="comment">%true generic conserved moieties, positive and not involving known mets</span>
0312     Ncm = N(:,~any(N &lt; 0, 1) &amp; ~any(N(metK,:),1));
0313     <span class="comment">%add them into formulas</span>
0314     metEle = [metEle, Ncm];
0315     ele = [eleK(:); cell(size(Ncm,2),1)];
0316     j2 = 1;
0317     <span class="keyword">for</span> j = 1:size(Ncm,2)
0318         <span class="keyword">while</span> any(strcmp(ele(1:nE),[<span class="string">'Conserve_'</span> <a href="#_sub1" class="code" title="subfunction s = num2alpha(index,charSet)">num2alpha</a>(j2)]))
0319             j2 = j2 + 1;
0320         <span class="keyword">end</span>
0321         ele{nE+j} = [<span class="string">'Conserve_'</span> <a href="#_sub1" class="code" title="subfunction s = num2alpha(index,charSet)">num2alpha</a>(j2)];
0322         j2 = j2 + 1;
0323     <span class="keyword">end</span>
0324 <span class="keyword">else</span>
0325     ele = eleK(:);
0326 <span class="keyword">end</span>
0327 rxnBal = metEle' * model.S;
0328 model.metFormulas = <a href="../MatlabCobraToolbox/auxiliary_functions/convertMatrixFormulas.html" class="code" title="function metForm = convertMatrixFormulas(element, metEle, dMax)">convertMatrixFormulas</a>(ele,metEle,10);
0329 <span class="keyword">if</span> nameCM &gt; 0 &amp;&amp; findCM ~= 0
0330     <span class="comment">%manually name conserved moieties</span>
0331     ele0 = ele;
0332     nDefault = 0;
0333     nCM = size(Ncm,2);
0334     eleDel = false(nE + nCM, 1);
0335     <span class="keyword">if</span> nameCM == 1
0336         <span class="comment">%get dead end metatbolites</span>
0337         [~,removedMets] = removeDeadEnds(model);
0338         metDead = findMetIDs(model,removedMets);
0339     <span class="keyword">end</span>
0340     <span class="keyword">for</span> j = 1:nCM
0341         fprintf(<span class="string">'\n'</span>);
0342         writeCell2Text([model.mets(Ncm(:,j)~=0),model.metFormulas(Ncm(:,j)~=0),<span class="keyword">...</span>
0343             model.metNames(Ncm(:,j)~=0)]);
0344         fprintf(<span class="string">'\n'</span>);
0345         <span class="keyword">if</span> nameCM == 1 &amp;&amp; any(Ncm(metDead,j),1)
0346             <span class="comment">%use the defaulted for dead end mets</span>
0347             nDefault = nDefault + 1;
0348             ele{nE+j} = ele0{nE + nDefault};
0349         <span class="keyword">else</span>
0350             cont = false;
0351             <span class="keyword">while</span> true
0352                 s = input([<span class="string">'Enter the formula for the conserved moiety (e.g. OHRab_cd):\n'</span>,<span class="keyword">...</span>
0353                     <span class="string">'(hit return to use default name ''Conserve_xxx'')\n'</span>],<span class="string">'s'</span>);
0354                 <span class="keyword">if</span> isempty(s)
0355                     <span class="comment">%use the defaulted</span>
0356                     nDefault = nDefault + 1;
0357                     ele{nE+j} = ele0{nE + nDefault};
0358                     <span class="keyword">break</span>
0359                 <span class="keyword">end</span>
0360                 re = regexp(s,<span class="string">'[A-Z][a-z_]*(\-?\d+\.?\d*)?'</span>,<span class="string">'match'</span>);
0361                 <span class="keyword">if</span> strcmp(strjoin(re,<span class="string">''</span>),s)
0362                     <span class="comment">%manual input formula, continue to checking</span>
0363                     cont = true;
0364                     <span class="keyword">break</span>
0365                 <span class="keyword">end</span>
0366             <span class="keyword">end</span>
0367             <span class="keyword">if</span> cont
0368                 <span class="comment">%get the matrix for the input formula</span>
0369                 nEnew = numel(ele) - nE - nCM;
0370                 [~, eleJ, metEleJ] = <a href="../MatlabCobraToolbox/auxiliary_functions/checkEleBalance.html" class="code" title="function [EleBal, element, metEle] = checkEleBalance(model, element, metEle,selfCall)">checkEleBalance</a>(s,ele([1:nE, (nE+nCM+1):end]));
0371                 metEle(:,[1:nE, (nE+nCM+1):end]) = metEle(:,[1:nE, (nE+nCM+1):end])<span class="keyword">...</span>
0372                         + metEle(:,nE+j) * metEleJ(1,1:(nE+nEnew));
0373                 <span class="keyword">if</span> numel(eleJ) &gt; nE + nEnew
0374                     <span class="comment">%there are new elements</span>
0375                     ele = [ele(:); eleJ((numel(ele)-nCM+1):end)];
0376                     metEle = [metEle, metEle(:,nE+j) * metEleJ(1,(nE+nEnew+1):end)];
0377                 <span class="keyword">end</span>
0378 <span class="comment">%                 [ynJ,idJ] = ismember(eleJ,ele(1:nE));</span>
0379 <span class="comment">%                 if any(ynJ)</span>
0380 <span class="comment">%                     metEle(:,idJ(ynJ)) = metEle(:,idJ(ynJ)) + metEle(:,nE+j) * metEleJ(1,ynJ);</span>
0381 <span class="comment">%                 end</span>
0382 <span class="comment">%                 eleJ = eleJ(~ynJ);</span>
0383 <span class="comment">%                 metEleJ = metEleJ(1,~ynJ);</span>
0384 <span class="comment">%                 if numel(ele) &gt; nE + nCM</span>
0385 <span class="comment">%                     [ynJ,idJ] = ismember(eleJ,ele(nE+nCM+1:end));</span>
0386 <span class="comment">%                     if any(ynJ)</span>
0387 <span class="comment">%                         metEle(:,nE+nCM+idJ(ynJ)) = metEle(:,nE+nCM+idJ(ynJ)) ...</span>
0388 <span class="comment">%                             + metEle(:,nE+j) * metEleJ(1,ynJ);</span>
0389 <span class="comment">%                     end</span>
0390 <span class="comment">%                     eleJ = eleJ(~ynJ);</span>
0391 <span class="comment">%                     metEleJ = metEleJ(1,~ynJ);</span>
0392 <span class="comment">%                 end</span>
0393 <span class="comment">%                 if ~isempty(eleJ)</span>
0394 <span class="comment">%                     ele = [ele(:);eleJ(:)];</span>
0395 <span class="comment">%                     metEle = [metEle, metEleJ];</span>
0396 <span class="comment">%                 end</span>
0397                 eleDel(nE + j) = true;
0398             <span class="keyword">end</span>
0399         <span class="keyword">end</span>
0400     <span class="keyword">end</span>
0401     <span class="comment">%del defaulted but replaced columns</span>
0402     <span class="keyword">if</span> any(eleDel)
0403         eleDel = find(eleDel);
0404         ele(eleDel) = [];
0405         metEle(:,eleDel) = [];
0406     <span class="keyword">end</span>
0407     <span class="comment">%1:nE              : real elements</span>
0408     <span class="comment">%nE+1:nE+nDefault  : default generic elements (Conserve_xxx)</span>
0409     <span class="comment">%nE+nDeafult+1:end : generic element by user's input</span>
0410     <span class="comment">%Change if names of default generic elements are mixed up with user</span>
0411     <span class="comment">%input</span>
0412     j0 = 0;
0413     <span class="keyword">for</span> j = 1:nDefault
0414         j0 = j0 + 1;
0415         nameJ = [<span class="string">'Conserve_'</span> <a href="#_sub1" class="code" title="subfunction s = num2alpha(index,charSet)">num2alpha</a>(j0)];
0416         <span class="keyword">while</span> any(strcmp(ele([1:nE, nE+nDefault+1:end]),nameJ))
0417             j0 = j0 + 1;
0418             nameJ = [<span class="string">'Conserve_'</span> <a href="#_sub1" class="code" title="subfunction s = num2alpha(index,charSet)">num2alpha</a>(j0)];
0419         <span class="keyword">end</span>
0420         ele{nE+j} = nameJ;
0421     <span class="keyword">end</span>
0422 <span class="keyword">end</span>
0423 model.metFormulas = <a href="../MatlabCobraToolbox/auxiliary_functions/convertMatrixFormulas.html" class="code" title="function metForm = convertMatrixFormulas(element, metEle, dMax)">convertMatrixFormulas</a>(ele,metEle,10);
0424 metCompute = [model.mets(metU) model.metFormulas(metU)];
0425 <span class="keyword">end</span>
0426 
0427 <a name="_sub1" href="#_subfunctions" class="code">function s = num2alpha(index,charSet)</a>
0428 <span class="comment">%s = num2alpha(j,charSet)</span>
0429 <span class="comment">%Given a nonzero integer j and a character set charSet, convert j into</span>
0430 <span class="comment">%a string formed from the characters in charSet having order j.</span>
0431 <span class="comment">%'charSet' defaulted to be '_abcdefghijklmnopqrstuvwxyz' in which '_' acts</span>
0432 <span class="comment">%like 0 and 'z' acts like the largest digit 9 in decimal expression</span>
0433 <span class="comment">%e.g. num2slpha(0) is '_' , num2slpha(1) is 'a', num2slpha(27^2) is 'a__'</span>
0434 <span class="comment">%</span>
0435 <span class="keyword">if</span> nargin &lt; 2
0436     charSet = [<span class="string">'_'</span> char(97:122)];
0437 <span class="keyword">end</span>
0438 <span class="keyword">if</span> numel(index) &gt; 1
0439     s = cell(numel(index),1);
0440     <span class="keyword">for</span> j = 1:numel(index)
0441         s{j} = <a href="#_sub1" class="code" title="subfunction s = num2alpha(index,charSet)">num2alpha</a>(index(j),charSet);
0442     <span class="keyword">end</span>
0443     <span class="keyword">return</span>
0444 <span class="keyword">end</span>
0445 N = length(charSet);
0446 s = <span class="string">''</span>;
0447 k = floor(index/N);
0448 <span class="keyword">while</span> k &gt; 0
0449     s = [s charSet(index - k*N + 1)];
0450     index = k;
0451     k = floor(index/N);
0452 <span class="keyword">end</span>
0453 s = [charSet(mod(index,N) + 1) s];
0454 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Tue 09-May-2017 12:37:40 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2003</address>
</body>
</html>