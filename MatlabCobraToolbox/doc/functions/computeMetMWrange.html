<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of computeMetMWrange</title>
  <meta name="keywords" content="computeMetMWrange">
  <meta name="description" content="Compute the minimum and maximum molecular weight (MW) of a metabolie">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- menu.html functions -->
<h1>computeMetMWrange
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>Compute the minimum and maximum molecular weight (MW) of a metabolie</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [metMWrange,metForm,metFeas,rxnBal,ele,metEle,LP] = computeMetMWrange(model,metKnown,metInterest,rxns,percent,param) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Compute the minimum and maximum molecular weight (MW) of a metabolie
 given a set of formulas for the known metabolites using a set of reactions. 
 Done by first minimizing the mass-and-charge imbalance. Then fixing the 
 imbalance at the minimum or higher level, minimize and maximize the molecular
 weight of the met of interest.

[metMWrange,metForm,metFeas,rxnBal,ele,metEle,LP] = computeMetMWrange(model,metKnown,metInterest,rxns,percent,param)
 Input: 
    model         COBRA model
    metKnown      A known set of metabolites with formulas (character array or IDs)
    metInterest   The metabolite of interest (character or ID)
    rxns          The set of reactions used to compute the formula of metInterest 
                  (character array or IDs)
    (optional)
    percent       The percent of inconsistency allowed when calculating the range
                  for the molecular weight. The constraints added are
                  sum(inconsistency_e) &lt;= min(sum(inconsistency_e)) * (1 + percent)
                  for each element e. Default percent = 0
    param         parameter structure for Cplex

 Output:
    metMWrange    [min MW, max MW] (1 x 2 vector)
    metForm       The corresponding empirical formulas (1 x 2 cell array)
    metFeas       Infeasibility from the corresponding optimization (1 x 2 vector)
    rxnBal        imbalance of each reaction (#element x #rxns matrix)
    ele           elements corresponding to the row of rxnBal, as well as
                  to the coloumn of metEle
    metEle        chemical formulas in a M by E matrix
    LP            Cplex LP structure</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="../functions/auxiliary_functions/MW.html" class="code" title="function [mw, elRes, stRes] = MW(form)">MW</a>	Return the molecular weight for the cell array or string of formula 'form'</li><li><a href="../functions/auxiliary_functions/checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>	Check the feasibility of a solution given a COBRA model structure or a CPLEX dynamic object and a solution</li><li><a href="../functions/auxiliary_functions/convertMatrixFormulas.html" class="code" title="function metForm = convertMatrixFormulas(element, metEle, dMax)">convertMatrixFormulas</a>	Convert the matrix form of the chemical formulae into string form</li><li><a href="../functions/auxiliary_functions/setCplexParam.html" class="code" title="function LP = setCplexParam(LP, solverParam,verbFlag)">setCplexParam</a>	Set the parameters of the CPLEX object according to the structure solverParam</li><li><a href="checkEleBalance.html" class="code" title="function [EleBal, element, metEle] = checkEleBalance(model, element, metEle,selfCall)">checkEleBalance</a>	Check the elemental balance of the reactions in the COBRA mode 'model'.</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [mw, elRes, stRes] = MW(form)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [metMWrange,metForm,metFeas,rxnBal,ele,metEle,LP] = computeMetMWrange(model,metKnown,metInterest,rxns,percent,param)</a>
0002 <span class="comment">% Compute the minimum and maximum molecular weight (MW) of a metabolie</span>
0003 <span class="comment">% given a set of formulas for the known metabolites using a set of reactions.</span>
0004 <span class="comment">% Done by first minimizing the mass-and-charge imbalance. Then fixing the</span>
0005 <span class="comment">% imbalance at the minimum or higher level, minimize and maximize the molecular</span>
0006 <span class="comment">% weight of the met of interest.</span>
0007 <span class="comment">%</span>
0008 <span class="comment">%[metMWrange,metForm,metFeas,rxnBal,ele,metEle,LP] = computeMetMWrange(model,metKnown,metInterest,rxns,percent,param)</span>
0009 <span class="comment">% Input:</span>
0010 <span class="comment">%    model         COBRA model</span>
0011 <span class="comment">%    metKnown      A known set of metabolites with formulas (character array or IDs)</span>
0012 <span class="comment">%    metInterest   The metabolite of interest (character or ID)</span>
0013 <span class="comment">%    rxns          The set of reactions used to compute the formula of metInterest</span>
0014 <span class="comment">%                  (character array or IDs)</span>
0015 <span class="comment">%    (optional)</span>
0016 <span class="comment">%    percent       The percent of inconsistency allowed when calculating the range</span>
0017 <span class="comment">%                  for the molecular weight. The constraints added are</span>
0018 <span class="comment">%                  sum(inconsistency_e) &lt;= min(sum(inconsistency_e)) * (1 + percent)</span>
0019 <span class="comment">%                  for each element e. Default percent = 0</span>
0020 <span class="comment">%    param         parameter structure for Cplex</span>
0021 <span class="comment">%</span>
0022 <span class="comment">% Output:</span>
0023 <span class="comment">%    metMWrange    [min MW, max MW] (1 x 2 vector)</span>
0024 <span class="comment">%    metForm       The corresponding empirical formulas (1 x 2 cell array)</span>
0025 <span class="comment">%    metFeas       Infeasibility from the corresponding optimization (1 x 2 vector)</span>
0026 <span class="comment">%    rxnBal        imbalance of each reaction (#element x #rxns matrix)</span>
0027 <span class="comment">%    ele           elements corresponding to the row of rxnBal, as well as</span>
0028 <span class="comment">%                  to the coloumn of metEle</span>
0029 <span class="comment">%    metEle        chemical formulas in a M by E matrix</span>
0030 <span class="comment">%    LP            Cplex LP structure</span>
0031 
0032 <span class="comment">%check mets with formulas that need to be transformed</span>
0033 <span class="comment">%form0 = model.metFormulas;</span>
0034 <span class="keyword">if</span> nargin &lt; 6
0035     param = struct();
0036 <span class="keyword">end</span>
0037 <span class="keyword">if</span> nargin &lt; 5 || isempty(percent)
0038     percent = 0;
0039 <span class="keyword">end</span>
0040 <span class="keyword">if</span> nargin &lt; 4 || isempty(rxns)
0041     rxnC = find(sum(model.S~=0,1)&gt;1 &amp; (model.lb ~=0 | model.ub ~= 0)')';
0042 <span class="keyword">elseif</span> iscell(rxns) || ischar(rxns)
0043     rxnC = findRxnIDs(model,rxns);
0044 <span class="keyword">else</span>
0045     rxnC = rxns;
0046 <span class="keyword">end</span>
0047 <span class="keyword">if</span> any(rxnC == 0)
0048     error(<span class="string">'%s in rxns is not in the model.'</span>, rxns{find(rxnC==0,1)});
0049 <span class="keyword">end</span>
0050 <span class="keyword">if</span> nargin &lt; 2 || isempty(metKnown)
0051     metKnown = model.mets(~cellfun(@isempty,model.metFormulas));
0052 <span class="keyword">end</span>
0053 <span class="keyword">if</span> iscell(metKnown) || ischar(metKnown)
0054     metK = findMetIDs(model,metKnown);
0055 <span class="keyword">else</span>
0056     metK = metKnown;
0057 <span class="keyword">end</span>
0058 <span class="keyword">if</span> any(metK == 0)
0059     error(<span class="string">'%s in metKnown is not in the model.'</span>, metKnown{find(metK==0,1)});
0060 <span class="keyword">end</span>
0061 <span class="keyword">if</span> iscell(metInterest) || ischar(metInterest)
0062     metInterest = findMetIDs(model,metInterest);
0063 <span class="keyword">end</span>
0064 metInterest0 = metInterest;
0065 <span class="keyword">if</span> metInterest == 0
0066     error(<span class="string">'The biomass met ID is incorrect.'</span>);
0067 <span class="keyword">elseif</span> ismember(metInterest,metK)
0068     metK(metK == metInterest) = [];
0069 <span class="keyword">end</span>
0070 metKform = cellfun(@isempty,model.metFormulas(metK));
0071 <span class="keyword">if</span> any(metKform)
0072     warning(<span class="string">'Some mets in metKnown do not have formulas in the model. Ignore them.'</span>);
0073 <span class="keyword">end</span>
0074 <span class="comment">%All formulas must be in the form of e.g. Abc2Bcd1. Elements are</span>
0075 <span class="comment">%represented by one capital letter followed by lower case letter or</span>
0076 <span class="comment">%underscore, followed by a number for the stoichiometry. No brackets or</span>
0077 <span class="comment">%other symbols allowed.</span>
0078 [metK,metKform] = deal(metK(~metKform), model.metFormulas(metK(~metKform)));
0079 re = regexp(metKform,<span class="string">'[A-Z][a-z_]*(\-?\d+\.?\d*)?'</span>,<span class="string">'match'</span>);
0080 re = cellfun(@(x) strjoin(x,<span class="string">''</span>),re,<span class="string">'UniformOutput'</span>,false);
0081 goodForm = strcmp(re, strtrim(metKform));
0082 <span class="keyword">if</span> ~all(goodForm)
0083     goodForm = find(~goodForm,1);
0084     error(<span class="string">'%s has an invalid formula %s\n'</span>,metKnown{goodForm},metKform{goodForm});
0085 <span class="keyword">end</span>
0086 
0087 <span class="comment">%% minimum inconsistency</span>
0088 [~,ele,metEleK] = <a href="checkEleBalance.html" class="code" title="function [EleBal, element, metEle] = checkEleBalance(model, element, metEle,selfCall)">checkEleBalance</a>(metKform);
0089 eleCh = strcmp(ele,<span class="string">'Charge'</span>);
0090 m = size(model.S,1);
0091 nE = numel(ele);
0092 mK = numel(metK);
0093 mU = m - mK;
0094 metU = setdiff((1:m)',metK);
0095 metInterest = find(metU == metInterest);
0096 nR = numel(rxnC);
0097 nameM = strcat(repmat(model.mets(metU), nE,1),<span class="string">'_'</span>, reshape(repmat(ele(:)',mU,1),nE*mU,1));
0098 nameR = strcat(repmat(model.rxns(rxnC), nE,1),<span class="string">'_'</span>, reshape(repmat(ele(:)',nR,1),nE*nR,1));
0099 LP = Cplex();
0100 <span class="comment">%n_ik, stoichoimetry for element k in met i</span>
0101 LP.addCols(zeros(mU*nE,1),[],zeros(mU*nE,1),inf(mU*nE,1),[],char(nameM));
0102 <span class="keyword">if</span> any(eleCh)
0103     <span class="comment">%if charge is in the formula, allow negative charges</span>
0104     eleChK = find(eleCh);
0105     LP.Model.lb((mU*(eleChK-1) + 1):(mU*eleChK)) = -inf;
0106 <span class="keyword">end</span>
0107 <span class="comment">%x^+_jk, positive inconsistency of element k in reaction j</span>
0108 LP.addCols(ones(nR*nE,1),[],zeros(nR*nE,1),inf(nR*nE,1),[],char(strcat(nameR,<span class="string">'_pos'</span>)));
0109 <span class="comment">%x^-_jk, negative inconsistency of element k in reaction j</span>
0110 LP.addCols(ones(nR*nE,1),[],zeros(nR*nE,1),inf(nR*nE,1),[],char(strcat(nameR,<span class="string">'_neg'</span>)));
0111 <span class="comment">%RHS</span>
0112 b = -model.S(metK,rxnC)' * metEleK;
0113 b = b(:);
0114 <span class="comment">%constraint matrix</span>
0115 [row,col,entry] = find(model.S(metU,rxnC)');
0116 row = repmat(row(:),nE,1)+reshape(repmat(0:nR:nR*(nE-1),numel(row),1),numel(row)*nE,1);
0117 col = repmat(col(:),nE,1)+reshape(repmat(0:mU:mU*(nE-1),numel(col),1),numel(col)*nE,1);
0118 entry = repmat(entry,nE,1);
0119 A = [sparse(row,col,entry,nR*nE,mU*nE), sparse(1:nR*nE,1:nR*nE,ones(nR*nE,1),nR*nE,nR*nE), <span class="keyword">...</span>
0120     sparse(1:nR*nE,1:nR*nE,-ones(nR*nE,1),nR*nE,nR*nE)];
0121 <span class="comment">% S_unknown' n_unknown = - S_known' * n_known</span>
0122 LP.addRows(b, A, b, char(strcat(nameR,<span class="string">'_bal'</span>)));
0123 <span class="comment">%Handle parameters</span>
0124 cobraParam = struct();
0125 cobraParamList = {<span class="string">'feasTol'</span>,<span class="string">'optTol'</span>};
0126 CplexParamList = {<span class="string">'feasibility'</span>,<span class="string">'optimality'</span>};
0127 [cobraParam.feasTol, cobraParam.optTol] = getCobraSolverParams(<span class="string">'LP'</span>,cobraParamList, param);
0128 <span class="keyword">for</span> j = 1:numel(CplexParamList)
0129     <span class="keyword">if</span> isfield(param,CplexParamList{j})
0130         cobraParam.(cobraParamList{j}) = param.(CplexParamList{j});
0131     <span class="keyword">elseif</span> isfield(param,<span class="string">'simplex'</span>) &amp;&amp; isfield(param.simplex,CplexParamList{j})
0132         cobraParam.(cobraParamList{j}) = param.simplex.(CplexParamList{j});
0133     <span class="keyword">elseif</span> isfield(param,<span class="string">'simplex'</span>) &amp;&amp; isfield(param.simplex,<span class="string">'tolerances'</span>) &amp;&amp; isfield(param.simplex.tolerances,CplexParamList{j})
0134         cobraParam.(cobraParamList{j}) = param.simplex.tolerances.(CplexParamList{j});
0135     <span class="keyword">else</span>
0136         param.simplex.tolerances.(CplexParamList{j}) = cobraParam.(cobraParamList{j});
0137     <span class="keyword">end</span>
0138 <span class="keyword">end</span>
0139 LP = <a href="../functions/auxiliary_functions/setCplexParam.html" class="code" title="function LP = setCplexParam(LP, solverParam,verbFlag)">setCplexParam</a>(LP,param);
0140 feasTol = LP.Param.simplex.tolerances.feasibility.Cur;
0141 <span class="comment">%Solve</span>
0142 LP.solve;
0143 <span class="comment">%manually check feasibility</span>
0144 feas = <a href="../functions/auxiliary_functions/checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP);
0145 <span class="keyword">if</span> ~(feas &lt;= feasTol)
0146     <span class="comment">%terminate if infeasible (should not happen)</span>
0147     <span class="keyword">if</span> isfield(LP.Solution,<span class="string">'x'</span>)
0148         metEle = zeros(numel(model.mets),numel(ele));
0149         metEle(metK,:) = metEleK;
0150         metEle(metU,:) = reshape(LP.Solution.x(1:mU*nE),mU,nE);
0151         rxnBal = metEle' * model.S;
0152     <span class="keyword">else</span>
0153         metEle = [];
0154         rxnBal = [];
0155     <span class="keyword">end</span>
0156     fprint(<span class="string">'Infeasible during optimization for minimal inconsistency.'</span>);
0157     <span class="keyword">return</span>
0158 <span class="keyword">end</span>
0159 x = LP.Solution.x;
0160 
0161 <span class="comment">%% metabolite MW range under minimum inconsistency</span>
0162 <span class="comment">%give bounds for the met of interest</span>
0163 LP.Model.ub(metInterest:mU:(metInterest+mU*(nE-1))) = 1e7;
0164 <span class="keyword">if</span> any(eleCh)
0165     LP.Model.lb(metInterest+mU*(find(eleCh)-1)) = -1e7;
0166 <span class="keyword">end</span>
0167 <span class="comment">% Constraint element-wise, sum(inconsist_e) &lt;= min_inconsist_e * (1+percent)</span>
0168 <span class="keyword">for</span> k = 1:nE
0169     ind = (mU*nE+nR*(k-1)+1):(mU*nE+nR*k);
0170     LP.addRows(0,<span class="keyword">...</span>
0171         sparse(ones(nR*2,1),[ind, (ind + nR*nE)], ones(nR*2,1),1,size(LP.Model.A,2)),<span class="keyword">...</span>
0172         sum(x([ind, (ind + nR*nE)]))*(1+1e-7+abs(percent))+1e-5, strcat(<span class="string">'min_incon_'</span>,ele{k}));
0173 <span class="keyword">end</span>
0174 <span class="comment">%molecular weight of each element</span>
0175 c = <a href="../functions/auxiliary_functions/MW.html" class="code" title="function [mw, elRes, stRes] = MW(form)">MW</a>(ele);
0176 c2 = c;
0177 c2(isnan(c)) = 0;
0178 <span class="comment">%change objective to the molecular weight of the met of interest</span>
0179 LP.Model.obj(:) = 0;
0180 LP.Model.obj(metInterest:mU:(metInterest+mU*(nE-1))) = c2;
0181 LP.Model.sense = <span class="string">'minimize'</span>;
0182 LP.solve;
0183 feas = <a href="../functions/auxiliary_functions/checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP);
0184 <span class="comment">%declare output variables</span>
0185 metFeas(1) = feas;
0186 metMWrange = zeros(1,2);
0187 metEle = NaN(numel(model.mets),numel(ele),2);
0188 
0189 [metEle(metK,:,1),metEle(metK,:,2)] = deal(metEleK);
0190 <span class="keyword">if</span> isfield(LP.Solution,<span class="string">'x'</span>)
0191     metEle(metU,:,1) = reshape(LP.Solution.x(1:mU*nE),mU,nE);
0192     metMWrange(1) = LP.Model.obj(:)' * LP.Solution.x;
0193 <span class="keyword">end</span>
0194 <span class="keyword">if</span> ~(feas &lt;= feasTol)
0195     <span class="comment">%may happen if scaling is allowed and meanwhile the met of interest can</span>
0196     <span class="comment">%have unbounded molecular weight</span>
0197     fprintf(<span class="string">'Infeasible during minimization for biomass weight.\n'</span>);
0198 <span class="keyword">end</span>
0199 LP.Model.sense = <span class="string">'maximize'</span>;
0200 LP.solve;
0201 feas = <a href="../functions/auxiliary_functions/checkSolFeas.html" class="code" title="function varargout = checkSolFeas(LP, sol, maxInfeas, tol, internal)">checkSolFeas</a>(LP);
0202 metFeas(2) = feas;
0203 <span class="keyword">if</span> isfield(LP.Solution,<span class="string">'x'</span>)
0204     metEle(metU,:,2) = reshape(LP.Solution.x(1:mU*nE),mU,nE);
0205     metMWrange(2) = LP.Model.obj(:)' * LP.Solution.x;
0206 <span class="keyword">end</span>
0207 rxnBal(:,:,1) = metEle(:,:,1)' * model.S;
0208 rxnBal(:,:,2) = metEle(:,:,2)' * model.S;
0209 <span class="keyword">if</span> ~(feas &lt;= feasTol)
0210     <span class="comment">%may happen if scaling is allowed and meanwhile the met of interest can</span>
0211     <span class="comment">%have unbounded molecular weight</span>
0212     fprintf(<span class="string">'Infeasible during maximization for biomass weight.\n'</span>);
0213 <span class="keyword">end</span>
0214 formBM0 = [metEle(metInterest0,:,1);metEle(metInterest0,:,2)];
0215 metForm = <a href="../functions/auxiliary_functions/convertMatrixFormulas.html" class="code" title="function metForm = convertMatrixFormulas(element, metEle, dMax)">convertMatrixFormulas</a>(ele,formBM0);
0216 metForm = metForm(:)';
0217 
0218 eleG = isnan(c) &amp; ~eleCh(:);
0219 <span class="keyword">if</span> any(abs(formBM0(:,eleG)) &gt; 1e-6,1)
0220     fprintf(<span class="string">'Biomass contains some generic groups.\n'</span>);
0221 <span class="keyword">end</span>
0222 
0223 <span class="keyword">end</span>
0224 
0225 <a name="_sub1" href="#_subfunctions" class="code">function [mw, elRes, stRes] = MW(form)</a>
0226 <span class="comment">%Return the molecular weight for the cell array or string of formula 'form'</span>
0227 <span class="comment">%The formulas must not have '(' and ')'.</span>
0228 <span class="comment">%Must be an elemental symbol followed by a number.</span>
0229 <span class="comment">%</span>
0230 <span class="comment">%Output:</span>
0231 <span class="comment">%  mw:      molecular weight, in g/mol</span>
0232 <span class="comment">%  elRes:   Unrecognized elements in form. MW assumes zero weight for them.</span>
0233 <span class="comment">%  stRes:   the elemental matrix for the columns corresponding to elRes</span>
0234 <span class="comment">%</span>
0235 <span class="comment">%Siu Hung Joshua Chan Nov 2016</span>
0236 
0237 [~,element, metEle] = <a href="checkEleBalance.html" class="code" title="function [EleBal, element, metEle] = checkEleBalance(model, element, metEle,selfCall)">checkEleBalance</a>(form);
0238 H = 1.00794; He = 4.002602; Li = 6.941; Be = 9.012182; B = 10.811; C = 12.011; N = 14.00674;
0239 O = 15.9994; F = 18.9984032; Ne = 20.1797; Na = 22.989768; Mg = 24.305; Al = 26.981539; Si = 28.0855;
0240 P = 30.973762; S = 32.066; Cl = 35.4527; Ar = 39.948; K = 39.0983; Ca = 40.078; Sc = 44.95591;
0241 Ti = 47.88; V = 50.9415; Cr = 51.9961; Mn = 54.93805; Fe = 55.847; Co = 58.9332; Ni = 58.69;
0242 Cu = 63.546; Zn = 65.39; Ga = 69.723; Ge = 72.61; As = 74.92159; Se = 78.96; Br = 79.904; Kr = 83.8;
0243 Rb = 85.4678; Sr = 87.62; Y = 88.90585; Zr = 91.224; Nb = 92.90638; Mo = 95.94; Tc = 98.9063;
0244 Ru = 101.07; Rh = 102.9055; Pd = 106.42; Ag = 107.8682; Cd = 112.411; In = 114.82; Sn = 118.71;
0245 Sb = 121.75; Te = 127.6; I = 126.90447; Xe = 131.29; Cs = 132.90543; Ba = 137.327; La = 138.9055;
0246 Ce = 140.115; Pr = 140.90765; Nd = 144.24; Pm = 146.9151; Sm = 150.36; Eu = 151.965; Gd = 157.25;
0247 Tb = 158.92534; Dy = 162.5; Ho = 164.93032; Er = 167.26; Tm = 168.93421; Yb = 173.04; Lu = 174.967;
0248 Hf = 178.49; Ta = 180.9479; W = 183.85; Re = 186.207; Os = 190.2; Ir = 192.22; Pt = 195.08;
0249 Au = 196.96654; Hg = 200.59; Tl = 204.3833; Pb = 207.2; Bi = 208.98037; Po = 208.9824; At = 209.9871;
0250 Rn = 222.0176; Ac = 223.0197; Th = 226.0254; Pa = 227.0278; U = 232.0381; Np = 231.0359; Pu = 238.0289;
0251 Am = 237.0482; Cm = 244.0642; Bk = 243.0614; Cf = 247.0703; Es = 247.0703; Fm = 251.0796; Md = 252.0829;
0252 No = 257.0951; Lr = 258.0986; Rf = 259.1009; Db = 260.1053; Sg = 261.1087; Bh = 262.1138; Hs = 263.1182;
0253 Mt = 262.1229;
0254 <span class="comment">% Unamed = NaN;</span>
0255 residue = false(numel(element),1);
0256 <span class="keyword">for</span> j = 1:numel(element)
0257     <span class="keyword">if</span> ~exist(element{j}, <span class="string">'var'</span>)
0258         residue(j) = true;
0259     <span class="keyword">end</span>
0260 <span class="keyword">end</span>
0261 <span class="keyword">if</span> all(residue)
0262     mw = NaN(size(metEle,1),1);
0263 <span class="keyword">else</span>
0264     v = [<span class="string">'[ '</span> strjoin(element(~residue), <span class="string">' '</span>) <span class="string">' ]'</span>];
0265     eval([<span class="string">'mw = metEle(:,~residue) * '</span> v <span class="string">''';'</span>]);
0266     mw(mw == 0) = NaN;
0267 <span class="keyword">end</span>
0268     elRes = element(residue);
0269     stRes = metEle(:, residue);
0270 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Fri 14-Apr-2017 17:13:46 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>